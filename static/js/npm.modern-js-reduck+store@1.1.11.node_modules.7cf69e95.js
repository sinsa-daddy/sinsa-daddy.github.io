"use strict";(globalThis.webpackChunk_sinsa_web=globalThis.webpackChunk_sinsa_web||[]).push([[6497],{400:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(90173);const o=e=>({define(t){let n;n="function"==typeof t?t:()=>t;const o=new Map,s=t=>{const n=n=>{const r=o.get(n);if(r)return r;const a=s(((...e)=>t(...e)));return o.set(n,a),a._name=n||e,a};return n._name=e,Object.defineProperty(n,r.fk,{configurable:!1,enumerable:!1,value:t}),n};return s(n)}})},1052:(e,t,n)=>{n.d(t,{Z:()=>r});const r=e=>e},76740:(e,t,n)=>{n.d(t,{Z:()=>k});var r=n(47778),o=n(88966),s=n(2031);const a=e=>{let t=null,n=null;return(...r)=>(((e,t)=>{if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const{length:n}=e;for(let r=0;r<n;r++)if(e[r]!==t[r])return!1;return!0}return!1})(t,r)||(n=e(...r),t=r),n)},c=e=>a(e);var i=n(90173);const l=(e,t)=>!(!t.name||"string"!=typeof t.name)||(console.error(`model name expected is a valid string, but got ${t.name}`),!1),u=(e={},t)=>Object.keys(e).reduce(((n,r)=>{const o=d(r,e[r],t);return n[r]={get(){return o(this)},enumerable:!1,configurable:!0},n}),{}),p=(e,t,n,o)=>{if(!t)return null;let s=o&&u(o,e.apis.useModel);const a=(0,i.uO)(o);return(c=n,l)=>{const p=l.type,d=t[p];let m=c;if((e=>a.some((t=>e.split("/")[0]===t._name.toUpperCase())))(p)&&(m=(0,r._)({},c),s=o&&u(o,e.apis.useModel)),d&&(m=e.pluginCore.invokePipeline("beforeReducer",t[l.type],{name:l.type,computedDescriptors:s})(c,l.payload,...l.extraArgs||[])),s&&(0,i.sU)(m)!==i.Yk.Object)throw Error("Only object type state can have computed properties.");return s?Object.defineProperties(m,s):m}},d=(e,t,n)=>{let r,o;const s=(e,...t)=>{const n=e(...t);return"function"==typeof n?c(((...e)=>n(...e))):n};if("function"==typeof t)r=e=>s(t,e);else if(Array.isArray(t)){o=t.slice(0,-1);const a=t.slice(-1)[0];if(!o.every((e=>(0,i.vP)(e)))||"function"!=typeof a)throw new Error(`The types of computed property parameters are not correct. Computed property name: ${e}`);r=e=>s(a,e,...o.map((e=>n(e)[0])))}return c(r)},m=e=>{const t={};return g(e,((e,n)=>{t[e.join("/").toUpperCase()]=n})),t},f=(e,t)=>{const n={},r=(e,t)=>{let r=n;const o=e.length;for(let n=1;n<o-1;n++)r[e[n]]||(r[e[n]]={}),r=r[e[n]];r[e[o-1]]?r[e[o-1]]=Object.assign(t,r[e[o-1]]):r[e[o-1]]=t};return g(t,(t=>r(t,((n,...r)=>e.store.dispatch({type:t.join("/").toUpperCase(),payload:n,extraArgs:r}))))),[n,r]},g=(e,t)=>{const n=[e.name],r=e=>e?"function"==typeof e?t(n.slice(),e):(Object.keys(e).forEach((t=>{n.push(t),r(e[t]),n.pop()})),null):null;r(e.actions||{})},b=()=>{const e=[];return{onMount:t=>{e.push(t)},trigger:()=>{e.forEach((e=>e()))}}},h=(e,t)=>{if(e.apis.getModel(t))return;const{onMount:n,trigger:r}=b();let o=(0,i.MB)(t)(e,{use:e.apis.useModel,onMount:n});if(o.name=t._name,o=e.pluginCore.invokePipeline("prepareModelDesc",o),!l(e,o))return;e.apis.mountingModel(t._name);const s=m(o),a=p(e,s,o.state,o.computed);a&&e.apis.addReducers({[o.name]:a});const[c,u]=f(e,o);let d={actions:c,state:o.state,name:o.name,modelDesc:o};({mountedModel:d}=e.pluginCore.invokePipeline("modelMount",{modelDesc:o,mountedModel:d},{setDispatchAction:u})),e.apis.addModel(t,d),r()},y=Symbol("getUnsubscribe"),M=(e,t)=>{const n=e.apis.getModel(t);if(!n)return null;const{name:r}=n;let o,s=e.store.getState()[r];const a=new Set,c=t=>(o=o||(o=e.store.subscribe((()=>{const t=e.store.getState()[r];s!==t&&(s=t,a.forEach((e=>e())))})),o),a.add(t),()=>{a.delete(t),0===a.size&&(null==o||o(),o=null)});return c[y]=()=>o,c};const _=(e,t)=>{const n=Array.isArray(t)?t:[t],o=[],s=[];for(const r of n)(0,i.vP)(r)?o.push(r):s.push(r);const[a,c]=s;o.length>1&&o.forEach((t=>{if("[object Object]"!==Object.prototype.toString.call(e.apis.getModel(t).state))throw new Error("You cant use multiple model one of which's state is primitive data")}));const l=t=>{const{state:n,modelDesc:{computed:o}}=e.apis.getModel(t);let s;return o?(s=Object.keys(o).reduce(((e,t)=>(e[t]=n[t],e)),{}),(0,r._)({},n,s)):n},u=c||((...e)=>e.reduce(((e,t)=>Object.assign(e,t)),{}));return{getState:()=>((...e)=>a?a(...o.map((e=>l(e)))):1===e.length?l(e[0]):e.reduce(((e,t)=>(0,r._)({},e,l(t))),{}))(...o),getActions:()=>u(...o.map((t=>e.apis.getModel(t).actions))),subscribe:t=>((e,...t)=>{const{store:n}=e;let r=!1;const o=new Set;return e=>{o.add(e);const s=[];t.forEach((e=>{s.push(e((()=>{r=!0})))}));const a=n.subscribe((()=>{r&&(r=!1,o.forEach((e=>e())))}));return()=>{a(),s.forEach((e=>e()))}}})(e,...o.map((t=>e.apis.getModelSubscribe(t))))(t),actualModels:o}},v="__REDUCK_DUMMY_REDUCER__",E=e=>{const t={},n=new Map,r=new Map,o=new Set;let a;const c=e=>{const t=l(e._name);return t?{name:t.name,state:a[t.name],actions:t.actions,modelDesc:t.modelDesc}:null},l=e=>{let t=null;for(const[,r]of n)if(r.name===e){t=r;break}return t},u=(e=>{const t=[],n=e=>t.map((t=>t[e])).filter(Boolean);return{usePlugin:n=>{t.push(n(e))},invokePipeline:(e,t,...r)=>{const o=n(e);let s=t;for(const n of o)s=n(s,...r);return s},invokeWaterFall:(e,...t)=>n(e).forEach((e=>e(...t)))}})({store:e}),p={store:e,apis:{addReducers:n=>{a||e.subscribe((()=>{a=e.getState()})),t[v]&&delete t[v],Object.assign(t,n),Object.keys(n).forEach((e=>o.delete(e))),e.replaceReducer((0,s.UY)(t))},addModel:(e,t)=>{n.set(e._name,t),r.set(e._name,M(p,e))},getModel:c,getModelSubscribe:e=>r.get(e._name),mountingModel:e=>{if(o.has(e))throw new Error(`You are mounting the model: ${e} which is already in mounting process`);o.add(e)},unmountModel:o=>{var i;if(!c(o))return;null===(i=r.get(o._name)[y]())||void 0===i||i(),n.delete(o._name),r.delete(o._name),delete a[o._name],delete t[o._name],0===Object.keys(t).length&&(t[v]=()=>null),e.replaceReducer((0,s.UY)(t))}},pluginCore:u};return p.apis.useModel=function(e){return function(...t){const n=Array.isArray(t[0])?[...t[0],...t.slice(1)]:t;n.forEach((t=>{(0,i.vP)(t)&&h(e,t)}));const{getState:r,getActions:o,actualModels:s,subscribe:a}=_(e,n),c=s.map((t=>{const{modelDesc:{computed:n}}=e.apis.getModel(t);return n}));(0,i.uO)(c).forEach((t=>{(0,i.vP)(t)&&h(e,t)}));let[l,u]=[r(),o()];return({state:l,actions:u}=e.pluginCore.invokePipeline("useModel",{state:l,actions:u},{models:s,mountedModels:s.map((t=>e.apis.getModel(t)))})),[l,u,a]}}(p),p};const k=(e={})=>{var t;const n={},a=E(n);null==e||null===(t=e.plugins)||void 0===t||t.forEach((e=>a.pluginCore.usePlugin(e)));const c=a.pluginCore.invokePipeline("config",e),{initialState:i={},middlewares:l,enhancers:u=[],models:p=[]}=c;return Object.assign(n,(0,s.MT)((e=>e),i,(0,s.qC)(...[e=>(t,n)=>{const s=e=>{if("function"!=typeof e)throw new Error("Expected the reducer to be a function.");return(t=n,o)=>{const s=e(t,o);return/^@@redux\/REPLACE/.test(o.type)?(0,r._)({},t,s):s}},a=e(s(t));return(0,o._)((0,r._)({},a),{replaceReducer:e=>a.replaceReducer(s(e))})},l?(0,s.md)(...l):void 0,...u||[]].filter(Boolean)))),n.use=a.apis.useModel,n.unmount=a.apis.unmountModel,p.length>0&&n.use(p),a.pluginCore.invokeWaterFall("afterCreateStore",n),n}},90173:(e,t,n)=>{n.d(t,{MB:()=>o,Yk:()=>c,fk:()=>r,sU:()=>l,uO:()=>a,vP:()=>s});const r=Symbol.for("__reduck_model_initializer__"),o=e=>e[r],s=e=>e&&Boolean(o(e)),a=e=>{const t=[];return(Array.isArray(e)?e:[e]).forEach((n=>{e&&Object.keys(e).forEach((n=>{const r=e[n];Array.isArray(r)&&r.forEach((e=>{!t.includes(e)&&s(e)&&t.push(e)}))}))})),t};var c,i;(i=c||(c={})).Primitive="primitive",i.Array="array",i.Object="object";const l=e=>Array.isArray(e)?c.Array:"object"==typeof e&&"undefined"!=e?c.Object:c.Primitive}}]);