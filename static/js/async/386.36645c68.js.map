{"version":3,"file":"static/js/async/386.36645c68.js","sources":["webpack://@sinsa/web/../../node_modules/.pnpm/memoize-one@5.2.1/node_modules/memoize-one/dist/memoize-one.esm.js","webpack://@sinsa/web/../../node_modules/.pnpm/react-virtualized-auto-sizer@1.0.24_react-dom@18.2.0_react@18.2.0/node_modules/react-virtualized-auto-sizer/dist/react-virtualized-auto-sizer.esm.js?a79c","webpack://@sinsa/web/../../node_modules/.pnpm/react-window@1.8.10_react-dom@18.2.0_react@18.2.0/node_modules/react-window/dist/index.esm.js"],"sourcesContent":["var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import { Component, createElement } from 'react';\n\n/**\n * Detect Element Resize.\n * https://github.com/sdecima/javascript-detect-element-resize\n * Sebastian Decima\n *\n * Forked from version 0.5.3; includes the following modifications:\n * 1) Guard against unsafe 'window' and 'document' references (to support SSR).\n * 2) Defer initialization code via a top-level function wrapper (to support SSR).\n * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.\n * 4) Add nonce for style element.\n * 5) Use 'export' statement over 'module.exports' assignment\n **/\n\n// Check `document` and `window` in case of server-side rendering\nlet windowObject;\nif (typeof window !== \"undefined\") {\n  windowObject = window;\n\n  // eslint-disable-next-line no-restricted-globals\n} else if (typeof self !== \"undefined\") {\n  // eslint-disable-next-line no-restricted-globals\n  windowObject = self;\n} else {\n  windowObject = global;\n}\nlet cancelFrame = null;\nlet requestFrame = null;\nconst TIMEOUT_DURATION = 20;\nconst clearTimeoutFn = windowObject.clearTimeout;\nconst setTimeoutFn = windowObject.setTimeout;\nconst cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;\nconst requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;\nif (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {\n  // For environments that don't support animation frame,\n  // fallback to a setTimeout based approach.\n  cancelFrame = clearTimeoutFn;\n  requestFrame = function requestAnimationFrameViaSetTimeout(callback) {\n    return setTimeoutFn(callback, TIMEOUT_DURATION);\n  };\n} else {\n  // Counter intuitively, environments that support animation frames can be trickier.\n  // Chrome's \"Throttle non-visible cross-origin iframes\" flag can prevent rAFs from being called.\n  // In this case, we should fallback to a setTimeout() implementation.\n  cancelFrame = function cancelFrame([animationFrameID, timeoutID]) {\n    cancelAnimationFrameFn(animationFrameID);\n    clearTimeoutFn(timeoutID);\n  };\n  requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {\n    const animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {\n      clearTimeoutFn(timeoutID);\n      callback();\n    });\n    const timeoutID = setTimeoutFn(function timeoutCallback() {\n      cancelAnimationFrameFn(animationFrameID);\n      callback();\n    }, TIMEOUT_DURATION);\n    return [animationFrameID, timeoutID];\n  };\n}\nfunction createDetectElementResize(nonce) {\n  let animationKeyframes;\n  let animationName;\n  let animationStartEvent;\n  let animationStyle;\n  let checkTriggers;\n  let resetTriggers;\n  let scrollListener;\n  const attachEvent = typeof document !== \"undefined\" && document.attachEvent;\n  if (!attachEvent) {\n    resetTriggers = function (element) {\n      const triggers = element.__resizeTriggers__,\n        expand = triggers.firstElementChild,\n        contract = triggers.lastElementChild,\n        expandChild = expand.firstElementChild;\n      contract.scrollLeft = contract.scrollWidth;\n      contract.scrollTop = contract.scrollHeight;\n      expandChild.style.width = expand.offsetWidth + 1 + \"px\";\n      expandChild.style.height = expand.offsetHeight + 1 + \"px\";\n      expand.scrollLeft = expand.scrollWidth;\n      expand.scrollTop = expand.scrollHeight;\n    };\n    checkTriggers = function (element) {\n      return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;\n    };\n    scrollListener = function (e) {\n      // Don't measure (which forces) reflow for scrolls that happen inside of children!\n      if (e.target.className && typeof e.target.className.indexOf === \"function\" && e.target.className.indexOf(\"contract-trigger\") < 0 && e.target.className.indexOf(\"expand-trigger\") < 0) {\n        return;\n      }\n      const element = this;\n      resetTriggers(this);\n      if (this.__resizeRAF__) {\n        cancelFrame(this.__resizeRAF__);\n      }\n      this.__resizeRAF__ = requestFrame(function animationFrame() {\n        if (checkTriggers(element)) {\n          element.__resizeLast__.width = element.offsetWidth;\n          element.__resizeLast__.height = element.offsetHeight;\n          element.__resizeListeners__.forEach(function forEachResizeListener(fn) {\n            fn.call(element, e);\n          });\n        }\n      });\n    };\n\n    /* Detect CSS Animations support to detect element display/re-attach */\n    let animation = false;\n    let keyframeprefix = \"\";\n    animationStartEvent = \"animationstart\";\n    const domPrefixes = \"Webkit Moz O ms\".split(\" \");\n    let startEvents = \"webkitAnimationStart animationstart oAnimationStart MSAnimationStart\".split(\" \");\n    let pfx = \"\";\n    {\n      const elm = document.createElement(\"fakeelement\");\n      if (elm.style.animationName !== undefined) {\n        animation = true;\n      }\n      if (animation === false) {\n        for (let i = 0; i < domPrefixes.length; i++) {\n          if (elm.style[domPrefixes[i] + \"AnimationName\"] !== undefined) {\n            pfx = domPrefixes[i];\n            keyframeprefix = \"-\" + pfx.toLowerCase() + \"-\";\n            animationStartEvent = startEvents[i];\n            animation = true;\n            break;\n          }\n        }\n      }\n    }\n    animationName = \"resizeanim\";\n    animationKeyframes = \"@\" + keyframeprefix + \"keyframes \" + animationName + \" { from { opacity: 0; } to { opacity: 0; } } \";\n    animationStyle = keyframeprefix + \"animation: 1ms \" + animationName + \"; \";\n  }\n  const createStyles = function (doc) {\n    if (!doc.getElementById(\"detectElementResize\")) {\n      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360\n      const css = (animationKeyframes ? animationKeyframes : \"\") + \".resize-triggers { \" + (animationStyle ? animationStyle : \"\") + \"visibility: hidden; opacity: 0; } \" + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\n        head = doc.head || doc.getElementsByTagName(\"head\")[0],\n        style = doc.createElement(\"style\");\n      style.id = \"detectElementResize\";\n      style.type = \"text/css\";\n      if (nonce != null) {\n        style.setAttribute(\"nonce\", nonce);\n      }\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n        style.appendChild(doc.createTextNode(css));\n      }\n      head.appendChild(style);\n    }\n  };\n  const addResizeListener = function (element, fn) {\n    if (attachEvent) {\n      element.attachEvent(\"onresize\", fn);\n    } else {\n      if (!element.__resizeTriggers__) {\n        const doc = element.ownerDocument;\n        const elementStyle = windowObject.getComputedStyle(element);\n        if (elementStyle && elementStyle.position === \"static\") {\n          element.style.position = \"relative\";\n        }\n        createStyles(doc);\n        element.__resizeLast__ = {};\n        element.__resizeListeners__ = [];\n        (element.__resizeTriggers__ = doc.createElement(\"div\")).className = \"resize-triggers\";\n        const expandTrigger = doc.createElement(\"div\");\n        expandTrigger.className = \"expand-trigger\";\n        expandTrigger.appendChild(doc.createElement(\"div\"));\n        const contractTrigger = doc.createElement(\"div\");\n        contractTrigger.className = \"contract-trigger\";\n        element.__resizeTriggers__.appendChild(expandTrigger);\n        element.__resizeTriggers__.appendChild(contractTrigger);\n        element.appendChild(element.__resizeTriggers__);\n        resetTriggers(element);\n        element.addEventListener(\"scroll\", scrollListener, true);\n\n        /* Listen for a css animation to detect element display/re-attach */\n        if (animationStartEvent) {\n          element.__resizeTriggers__.__animationListener__ = function animationListener(e) {\n            if (e.animationName === animationName) {\n              resetTriggers(element);\n            }\n          };\n          element.__resizeTriggers__.addEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);\n        }\n      }\n      element.__resizeListeners__.push(fn);\n    }\n  };\n  const removeResizeListener = function (element, fn) {\n    if (attachEvent) {\n      element.detachEvent(\"onresize\", fn);\n    } else {\n      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n      if (!element.__resizeListeners__.length) {\n        element.removeEventListener(\"scroll\", scrollListener, true);\n        if (element.__resizeTriggers__.__animationListener__) {\n          element.__resizeTriggers__.removeEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);\n          element.__resizeTriggers__.__animationListener__ = null;\n        }\n        try {\n          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);\n        } catch (e) {\n          // Preact compat; see developit/preact-compat/issues/228\n        }\n      }\n    }\n  };\n  return {\n    addResizeListener,\n    removeResizeListener\n  };\n}\n\nclass AutoSizer extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      height: this.props.defaultHeight || 0,\n      scaledHeight: this.props.defaultHeight || 0,\n      scaledWidth: this.props.defaultWidth || 0,\n      width: this.props.defaultWidth || 0\n    };\n    this._autoSizer = null;\n    this._detectElementResize = null;\n    this._parentNode = null;\n    this._resizeObserver = null;\n    this._timeoutId = null;\n    this._onResize = () => {\n      this._timeoutId = null;\n      const {\n        disableHeight,\n        disableWidth,\n        onResize\n      } = this.props;\n      if (this._parentNode) {\n        // Guard against AutoSizer component being removed from the DOM immediately after being added.\n        // This can result in invalid style values which can result in NaN values if we don't handle them.\n        // See issue #150 for more context.\n\n        const style = window.getComputedStyle(this._parentNode) || {};\n        const paddingLeft = parseFloat(style.paddingLeft || \"0\");\n        const paddingRight = parseFloat(style.paddingRight || \"0\");\n        const paddingTop = parseFloat(style.paddingTop || \"0\");\n        const paddingBottom = parseFloat(style.paddingBottom || \"0\");\n        const rect = this._parentNode.getBoundingClientRect();\n        const scaledHeight = rect.height - paddingTop - paddingBottom;\n        const scaledWidth = rect.width - paddingLeft - paddingRight;\n        const height = this._parentNode.offsetHeight - paddingTop - paddingBottom;\n        const width = this._parentNode.offsetWidth - paddingLeft - paddingRight;\n        if (!disableHeight && (this.state.height !== height || this.state.scaledHeight !== scaledHeight) || !disableWidth && (this.state.width !== width || this.state.scaledWidth !== scaledWidth)) {\n          this.setState({\n            height,\n            width,\n            scaledHeight,\n            scaledWidth\n          });\n          if (typeof onResize === \"function\") {\n            onResize({\n              height,\n              scaledHeight,\n              scaledWidth,\n              width\n            });\n          }\n        }\n      }\n    };\n    this._setRef = autoSizer => {\n      this._autoSizer = autoSizer;\n    };\n  }\n  componentDidMount() {\n    const {\n      nonce\n    } = this.props;\n    const parentNode = this._autoSizer ? this._autoSizer.parentNode : null;\n    if (parentNode != null && parentNode.ownerDocument && parentNode.ownerDocument.defaultView && parentNode instanceof parentNode.ownerDocument.defaultView.HTMLElement) {\n      // Delay access of parentNode until mount.\n      // This handles edge-cases where the component has already been unmounted before its ref has been set,\n      // As well as libraries like react-lite which have a slightly different lifecycle.\n      this._parentNode = parentNode;\n\n      // Use ResizeObserver from the same context where parentNode (which we will observe) was defined\n      // Using just global can result into onResize events not being emitted in cases with multiple realms\n      const ResizeObserverInstance = parentNode.ownerDocument.defaultView.ResizeObserver;\n      if (ResizeObserverInstance != null) {\n        this._resizeObserver = new ResizeObserverInstance(() => {\n          // Guard against \"ResizeObserver loop limit exceeded\" error;\n          // could be triggered if the state update causes the ResizeObserver handler to run long.\n          // See https://github.com/bvaughn/react-virtualized-auto-sizer/issues/55\n          this._timeoutId = setTimeout(this._onResize, 0);\n        });\n        this._resizeObserver.observe(parentNode);\n      } else {\n        // Defer requiring resize handler in order to support server-side rendering.\n        // See issue #41\n        this._detectElementResize = createDetectElementResize(nonce);\n        this._detectElementResize.addResizeListener(parentNode, this._onResize);\n      }\n      this._onResize();\n    }\n  }\n  componentWillUnmount() {\n    if (this._parentNode) {\n      if (this._detectElementResize) {\n        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);\n      }\n      if (this._timeoutId !== null) {\n        clearTimeout(this._timeoutId);\n      }\n      if (this._resizeObserver) {\n        this._resizeObserver.disconnect();\n      }\n    }\n  }\n  render() {\n    const {\n      children,\n      defaultHeight,\n      defaultWidth,\n      disableHeight = false,\n      disableWidth = false,\n      doNotBailOutOnEmptyChildren = false,\n      nonce,\n      onResize,\n      style = {},\n      tagName = \"div\",\n      ...rest\n    } = this.props;\n    const {\n      height,\n      scaledHeight,\n      scaledWidth,\n      width\n    } = this.state;\n\n    // Outer div should not force width/height since that may prevent containers from shrinking.\n    // Inner component should overflow and use calculated width/height.\n    // See issue #68 for more information.\n    const outerStyle = {\n      overflow: \"visible\"\n    };\n    const childParams = {};\n\n    // Avoid rendering children before the initial measurements have been collected.\n    // At best this would just be wasting cycles.\n    let bailoutOnChildren = false;\n    if (!disableHeight) {\n      if (height === 0) {\n        bailoutOnChildren = true;\n      }\n      outerStyle.height = 0;\n      childParams.height = height;\n      childParams.scaledHeight = scaledHeight;\n    }\n    if (!disableWidth) {\n      if (width === 0) {\n        bailoutOnChildren = true;\n      }\n      outerStyle.width = 0;\n      childParams.width = width;\n      childParams.scaledWidth = scaledWidth;\n    }\n    if (doNotBailOutOnEmptyChildren) {\n      bailoutOnChildren = false;\n    }\n    return createElement(tagName, {\n      ref: this._setRef,\n      style: {\n        ...outerStyle,\n        ...style\n      },\n      ...rest\n    }, !bailoutOnChildren && children(childParams));\n  }\n}\n\nfunction isHeightAndWidthProps(props) {\n  return props && props.disableHeight !== true && props.disableWidth !== true;\n}\nfunction isHeightOnlyProps(props) {\n  return props && props.disableHeight !== true && props.disableWidth === true;\n}\nfunction isWidthOnlyProps(props) {\n  return props && props.disableHeight === true && props.disableWidth !== true;\n}\n\nexport { AutoSizer as default, isHeightAndWidthProps, isHeightOnlyProps, isWidthOnlyProps };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n"],"names":["safeIsNaN","Number","isNaN","value","areInputsEqual","newInputs","lastInputs","length","first","second","i","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","arguments","apply","windowObject","window","self","g","cancelFrame","requestFrame","clearTimeoutFn","clearTimeout","setTimeoutFn","setTimeout","cancelAnimationFrameFn","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","requestAnimationFrameFn","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","callback","animationFrameID","timeoutID","AutoSizer","Component","constructor","args","state","height","props","defaultHeight","scaledHeight","scaledWidth","defaultWidth","width","_autoSizer","_detectElementResize","_parentNode","_resizeObserver","_timeoutId","_onResize","disableHeight","disableWidth","onResize","style","getComputedStyle","paddingLeft","parseFloat","paddingRight","paddingTop","paddingBottom","rect","getBoundingClientRect","offsetHeight","offsetWidth","setState","_setRef","autoSizer","componentDidMount","nonce","parentNode","ownerDocument","defaultView","HTMLElement","ResizeObserverInstance","ResizeObserver","observe","createDetectElementResize","animationKeyframes","animationName","animationStartEvent","animationStyle","resetTriggers","scrollListener","attachEvent","document","element","triggers","__resizeTriggers__","expand","firstElementChild","contract","lastElementChild","expandChild","scrollLeft","scrollWidth","scrollTop","scrollHeight","e","target","className","indexOf","__resizeRAF__","__resizeLast__","__resizeListeners__","forEach","fn","call","animation","keyframeprefix","domPrefixes","split","startEvents","pfx","elm","createElement","undefined","toLowerCase","createStyles","doc","getElementById","css","head","getElementsByTagName","id","type","setAttribute","styleSheet","cssText","appendChild","createTextNode","addResizeListener","elementStyle","position","expandTrigger","contractTrigger","addEventListener","__animationListener__","push","removeResizeListener","detachEvent","splice","removeEventListener","removeChild","componentWillUnmount","disconnect","render","children","doNotBailOutOnEmptyChildren","tagName","rest","outerStyle","overflow","childParams","bailoutOnChildren","ref","_ref2","_class","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","now","hasNativePerformanceNow","performance","Date","cancelTimeout","requestTimeout","delay","start","tick","size","getScrollbarSize","recalculate","div","body","clientWidth","cachedRTLResult","getRTLOffsetType","outerDiv","direction","innerDiv","innerStyle","defaultItemKey","_ref","columnIndex","rowIndex","data","validateSharedProps","_ref5","_ref6","innerTagName","outerTagName","overscanColumnsCount","overscanCount","overscanRowsCount","instance","rowCount","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","numUnmeasuredItems","_ref3","_ref4","columnCount","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","columnWidth","rowHeight","findNearestItemBinarySearch","high","low","middle","Math","floor","currentOffset","findNearestItemExponentialSearch","itemCount","interval","min","defaultItemKey$1","validateSharedProps$1","layout","getItemMetadata$1","findNearestItemBinarySearch$1","findNearestItemExponentialSearch$1","FixedSizeGrid","_ref7","align","scrollbarSize","lastColumnOffset","max","maxOffset","minOffset","middleOffset","round","ceil","_ref8","lastRowOffset","_ref9","_ref10","startIndex","_ref11","_ref12","_ref13","_PureComponent","Grid","_this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","isScrolling","horizontalScrollDirection","initialScrollLeft","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","_offset","isRtl","left","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","prevState","calculatedScrollLeft","_resetIsScrollingDebounced","_outerRefSetter","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","_proto","prototype","scrollTo","scrollToItem","_ref4$align","_this$props2","_this$state","estimatedTotalHeight","horizontalScrollbarSize","estimatedTotalWidth","verticalScrollbarSize","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","_this$props4","innerRef","innerElementType","itemData","_this$props4$itemKey","itemKey","outerElementType","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","_this$state4","overscanCountResolved","stopIndex","_this$props7","overscanRowCount","_this$state5","PureComponent","defaultProps"],"mappings":"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"}